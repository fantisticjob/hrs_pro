/*package com.hausontech.hrs.daoImpl.allocationManager;

import java.sql.SQLException;
import java.util.List;
import java.util.Map;

import org.apache.commons.lang.StringUtils;
import org.springframework.jdbc.core.namedparam.BeanPropertySqlParameterSource;
import org.springframework.jdbc.core.namedparam.SqlParameterSource;

import com.hausontech.hrs.api.allocationManager.dao.IAllocationRulesSettingDao;
import com.hausontech.hrs.bean.AuditBean2;
import com.hausontech.hrs.bean.allocationManager.AllocDriverAccountBean;
import com.hausontech.hrs.bean.allocationManager.AllocRuleBean;
import com.hausontech.hrs.bean.allocationManager.AllocRulesGroupHaeaderBean;
import com.hausontech.hrs.bean.allocationManager.AllocRulesGroupLineBean;
import com.hausontech.hrs.bean.allocationManager.AllocSourceAccountBean;
import com.hausontech.hrs.bean.allocationManager.AllocSourceBean;
import com.hausontech.hrs.bean.allocationManager.AllocTargetAccountBean;
import com.hausontech.hrs.bean.allocationManager.DimFilterHeaderBean;
import com.hausontech.hrs.bean.allocationManager.DimFilterLineBean;
import com.hausontech.hrs.bean.allocationManager.DriverStaticHeader;
import com.hausontech.hrs.bean.allocationManager.DriverStaticLine;
import com.hausontech.hrs.bean.allocationManager.model.AllocDriverRecord;
import com.hausontech.hrs.bean.allocationManager.model.AllocTargetRecord;
import com.hausontech.hrs.bean.allocationManager.model.RoleRecord;
import com.hausontech.hrs.bean.dimensionManager.DimensionValueBean;
import com.hausontech.hrs.bean.userManager.RoleUserMapRecord;
import com.hausontech.hrs.daoImpl.BaseDaoImpl;
import com.hausontech.hrs.daoImpl.allocationManager.mapper.AllocDriverMapper;
import com.hausontech.hrs.daoImpl.allocationManager.mapper.AllocRuleMapper;
import com.hausontech.hrs.daoImpl.allocationManager.mapper.AllocRulesGroupHaeaderMapper;
import com.hausontech.hrs.daoImpl.allocationManager.mapper.AllocSourceMapper;
import com.hausontech.hrs.daoImpl.allocationManager.mapper.AllocTargetMapper;
import com.hausontech.hrs.daoImpl.allocationManager.mapper.AllocationRulesMapper;
import com.hausontech.hrs.daoImpl.allocationManager.mapper.DriverStaticHeaderMapper;
import com.hausontech.hrs.utils.StringUtil;

public class AllocationRulesSettingDaoImpl extends BaseDaoImpl implements IAllocationRulesSettingDao {
	
	public List<Map<String, Object>> findDimFilterHeader(DimFilterHeaderBean dfh) {
		StringBuffer sql = new StringBuffer();
		String condition;
		if ((StringUtils.isBlank(dfh.getFilterHeaderName())) && (StringUtils.isBlank(dfh.getDimensionSegment()))) {
			condition = "";
		} else {

			if (StringUtils.isBlank(dfh.getFilterHeaderName())) {
				condition = "Where DIMENSION_SEGMENT='" + dfh.getDimensionSegment()+"' ";
			} else {

				if (StringUtils.isBlank(dfh.getDimensionSegment())) {
					condition = "Where FILTER_HEADER_NAME='" + dfh.getFilterHeaderName()+"' ";
				} else {
					condition = "Where DIMENSION_SEGMENT='" + dfh.getDimensionSegment() + "' and FILTER_HEADER_NAME='"
							+ dfh.getFilterHeaderName()+"' ";
				}
			}
		}
		List<Map<String, Object>> list = null;
		sql.append(
				"select  ROW_NUMBER() OVER(ORDER BY FILTER_HEADER_ID) AS ROW_NUMBER,FILTER_HEADER_ID,FILTER_HEADER_NAME,DIMENSION_SEGMENT,TYPE,DESCRIPTION from hae_dim_filter_header ");
		sql.append(condition);
		if ((dfh.getRowStartIndex() != 0) && (dfh.getRowCount() != 0)) {
			sql = pageSql(sql, dfh.getRowStartIndex(), dfh.getRowCount());
		}
		list = this.namedjdbcTemplate.getJdbcOperations().queryForList(sql.toString());
		return list;
	}

	public int getCountFilterHeader(DimFilterHeaderBean dfh) {
		StringBuffer sql = new StringBuffer();
		sql.append("select count(FILTER_HEADER_ID) num from hae_dim_filter_header");
		return ((Integer) this.namedjdbcTemplate.getJdbcOperations().queryForObject(sql.toString(), Integer.TYPE))
				.intValue();
	}

	public void createNewFilterHeader(DimFilterHeaderBean dimFilterHeaderBean) {
		int primarykey = (int) getAutoGeneratedPrimaryKey("HAE_DIM_FILTER_HEADER_S");
		dimFilterHeaderBean.setFilterHeaderId(primarykey);
		String sql = "INSERT INTO HAE_DIM_FILTER_HEADER (FILTER_HEADER_ID,FILTER_HEADER_NAME,DIMENSION_SEGMENT,TYPE,DESCRIPTION,CREATED_BY,CREATED_DATE,LAST_UPDATED_BY,LAST_UPDATED_DATE)VALUES(:filterHeaderId,:filterHeaderName,:dimensionSegment,:type,:description,:createdBy,:creationDate,:lastUpdatedBy,:lastUpdateDate )";

		System.out.println(sql);
		SqlParameterSource namedParameters = new BeanPropertySqlParameterSource(dimFilterHeaderBean);
		this.namedjdbcTemplate.update(sql, namedParameters);
	}

	public boolean filterHeaderIsSegmentExist(String dimensionSegment) {
		return false;
	}

	public List<Map<String, Object>> getSegmentList(String condition) {
		if (condition == "filter") {
			List<Map<String, Object>> list = null;
			String sql = "SELECT DIM_SEGMENT,DIMENSION_NAME FROM(SELECT DIM_SEGMENT,DIMENSION_NAME FROM HRS_CORE_DIMENSION UNION ALL  SELECT 'LEDGER_ID' DIM_SEGMENT,'账套' DIMENSION_NAME FROM DUAL UNION ALL SELECT 'FIN_ELEMENT' DIM_SEGMENT,'财务要素' DIMENSION_NAME FROM DUAL)WHERE DIM_SEGMENT NOT IN (SELECT DIMENSION_SEGMENT FROM HAE_DIM_FILTER_HEADER)";
			list = this.namedjdbcTemplate.getJdbcOperations().queryForList(sql.toString());
			return list;
		}
		if (condition == "all") {
			List<Map<String, Object>> list = null;
			String sql = " SELECT DIM_SEGMENT,DIMENSION_NAME FROM HRS_CORE_DIMENSION UNION ALL  SELECT 'LEDGER_ID' DIM_SEGMENT,'账套' DIMENSION_NAME FROM DUAL UNION ALL SELECT 'FIN_ELEMENT' DIM_SEGMENT,'财务要素' DIMENSION_NAME FROM DUAL ";
			list = this.namedjdbcTemplate.getJdbcOperations().queryForList(sql.toString());
			return list;
		}
		return null;
	}

	@Override
	public List<Map<String, Object>> getRuleList() {
		List<Map<String, Object>> list = null;
		String sql = " SELECT RULE_ID,LINE_NUM,RULE_NAME,DESCRIPTION,DRIVER_TYPE,START_DATE_ACTIVE,END_DATE_ACTIVE FROM HAE_ALLOC_RULE  ";
		list = this.namedjdbcTemplate.getJdbcOperations().queryForList(sql.toString());
		return list;
	}
	
	@Override
	public List<Map<String, Object>> getStaticList() {
		List<Map<String, Object>> list = null;
		String sql = " SELECT STATIC_HEADER_ID,DRIVER_CODE FROM HAE_DRIVER_STATIC_HEADER  ";
		list = this.namedjdbcTemplate.getJdbcOperations().queryForList(sql.toString());
		return list;
	}
	
	
	public int updateDimFilterHeader(DimFilterHeaderBean updateBean) throws SQLException {
		int updateNum = 0;
		try {
			StringBuffer sql = new StringBuffer();
			sql.append("UPDATE HAE_DIM_FILTER_HEADER SET");
			sql.append(" FILTER_HEADER_NAME =NVL(:filterHeaderName,FILTER_HEADER_NAME),");
			sql.append(" DIMENSION_SEGMENT =NVL(:dimensionSegment,DIMENSION_SEGMENT),");
			sql.append(" TYPE =NVL(:type,TYPE),");
			sql.append(" DESCRIPTION =NVL(:description,DESCRIPTION),");
			sql.append(" LAST_UPDATED_BY =NVL(:lastUpdatedBy,LAST_UPDATED_BY),");
			sql.append(" LAST_UPDATED_DATE =NVL(:lastUpdateDate,LAST_UPDATED_DATE)");
			sql.append(" WHERE FILTER_HEADER_ID=:filterHeaderId");
			SqlParameterSource namedParameters = new BeanPropertySqlParameterSource(updateBean);

			updateNum = this.namedjdbcTemplate.update(sql.toString(), namedParameters);
		} catch (Exception e) {
			throw new SQLException(e);
		}
		return updateNum;
	}

	public DimFilterHeaderBean getDimFilterHeaderBeanById(int primaryKey) throws SQLException {
		StringBuffer sql = new StringBuffer();
		DimFilterHeaderBean result = null;
		try {
			sql.append(
					"select  ROW_NUMBER() OVER(ORDER BY FILTER_HEADER_ID) AS ROW_NUMBER,FILTER_HEADER_ID,FILTER_HEADER_NAME,DIMENSION_SEGMENT,TYPE,DESCRIPTION from hae_dim_filter_header ");
			sql.append(" WHERE FILTER_HEADER_ID=" + primaryKey);
			result = (DimFilterHeaderBean) this.namedjdbcTemplate.getJdbcOperations().queryForObject(sql.toString(),
					new AllocationRulesMapper());
		} catch (Exception e) {
			throw new SQLException(e);
		}
		return result;
	}

	public List<Map<String, Object>> getFilterLineValuesByCondition(DimFilterLineBean dimFilterLineBean)
			throws SQLException {
		String strCondition = BuildCondition(dimFilterLineBean);
		StringBuffer sql = new StringBuffer();
		List<Map<String, Object>> list = null;
		try {
			sql.append("SELECT ");
			if ((dimFilterLineBean.getRowStartIndex() != 0) && (dimFilterLineBean.getRowCount() != 0)) {
				sql.append(
						" FILTER_LINE_ID,FILTER_HEADER_ID,VALUE_LOW,VALUE_HIGH,INC_EXC_INDICATOR,DESCRIPTION,CREATED_BY,CREATED_DATE,LAST_UPDATED_BY,LAST_UPDATED_DATE,ROW_NUMBER() OVER (ORDER BY FILTER_LINE_ID)  AS row_number");
			} else {
				sql.append(
						" FILTER_LINE_ID,FILTER_HEADER_ID,VALUE_LOW,VALUE_HIGH,INC_EXC_INDICATOR,DESCRIPTION,CREATED_BY,CREATED_DATE,LAST_UPDATED_BY,LAST_UPDATED_DATE ");
			}
			sql.append(" from HAE_DIM_FILTER_LINE ");
			if ((null != strCondition) && (strCondition.length() > 0)) {
				sql.append(" WHERE " + strCondition);
			}
			if ((dimFilterLineBean.getRowStartIndex() != 0) && (dimFilterLineBean.getRowCount() != 0)) {
				sql = pageSql(sql, dimFilterLineBean.getRowStartIndex(), dimFilterLineBean.getRowCount());
			}
			list = this.namedjdbcTemplate.getJdbcOperations().queryForList(sql.toString());
		} catch (Exception e) {
			throw new SQLException(e);
		}
		return list;
	}

	private String BuildCondition(AuditBean2 conditionbean) {
		StringBuffer sb = new StringBuffer();
		if (conditionbean != null) {
			if ((conditionbean instanceof DimFilterLineBean)) {
				DimFilterLineBean searchBean = (DimFilterLineBean) conditionbean;
				if ((null != searchBean) && (searchBean.getFilterHeaderId() != 0)) {
					sb.append("FILTER_HEADER_ID=" + searchBean.getFilterHeaderId() + " ");
					return sb.toString();
				}
			} else if ((conditionbean instanceof DriverStaticHeader)) {
				DriverStaticHeader searchBean=(DriverStaticHeader) conditionbean;
				if (null!=searchBean){
					sb.append(" where 1=1 ");
					if(!StringUtils.isBlank(searchBean.getDescription())){
						sb.append(" and DESCRIPTION like '%"+searchBean.getDescription()+"%' ");
					}
					if(!StringUtils.isBlank(searchBean.getDriverCode())){
						sb.append(" and DRIVER_CODE like '%"+searchBean.getDriverCode()+"%' ");
					}
				}
			}else if (conditionbean instanceof DriverStaticLine){
				DriverStaticLine searchBean=(DriverStaticLine) conditionbean;
				if(null!=searchBean){
					sb.append(" where 1=1 ");
					if((null != searchBean) && (searchBean.getStaticHeaderId()!=0)){
						sb.append(" and STATIC_HEADER_ID="+searchBean.getStaticHeaderId()+" ");
					}
					if(!StringUtils.isBlank(searchBean.getDimValue())){
						sb.append( " and  DIM_VALUE like '%"+searchBean.getDimValue()+"%' ");
					}
					if(!StringUtils.isBlank(searchBean.getDriverName())){
						sb.append(" and DRIVER_NAME like '%"+searchBean.getDriverName()+"%' ");
					}
					
				}
			}else if(conditionbean instanceof AllocRulesGroupHaeaderBean){
				AllocRulesGroupHaeaderBean searchBean =(AllocRulesGroupHaeaderBean) conditionbean;
				if(null!=searchBean){
					sb.append(" where 1=1 ");
					if(!StringUtils.isBlank(searchBean.getGroupName())){
						sb.append(" and GROUP_NAME like '%"+searchBean.getGroupName()+"%'" );
					}
				}
			}else if (conditionbean instanceof AllocRulesGroupLineBean){
				AllocRulesGroupLineBean searchBean=(AllocRulesGroupLineBean) conditionbean;
				if(null!=searchBean){
					sb.append(" where 1=1 ");
					if((null != searchBean) && (searchBean.getGroupHeaderId()!=0)){
						sb.append(" and GROUP_HEADER_ID="+searchBean.getGroupHeaderId()+" ");
					}
				}
			}else if(conditionbean instanceof AllocRuleBean){
				AllocRuleBean searchBean=(AllocRuleBean) conditionbean;
				if(null!=conditionbean){
					sb.append(" where 1=1 ");
					if(!StringUtils.isBlank(searchBean.getRuleName())){
						sb.append( " and  RULE_NAME like '%"+searchBean.getRuleName()+"%' ");
					}
					if(!StringUtils.isBlank(searchBean.getDriverType())){
						sb.append( " and  DRIVER_TYPE like '%"+searchBean.getDriverType()+"%' ");
					}
				}
			}else if (conditionbean instanceof AllocDriverAccountBean){
				//条件需要重新判定
				AllocDriverAccountBean searchBean= (AllocDriverAccountBean) conditionbean;
				if(null!=searchBean){
					sb.append(" where 1=1 ");
					if((null != searchBean) && (searchBean.getDrvierAccId()!=0)){
						sb.append(" and DRVIER_ACC_ID="+searchBean.getDrvierAccId()+" ");
					}
				}
			}else if (conditionbean instanceof AllocSourceBean){
				AllocSourceBean searchBean= (AllocSourceBean) conditionbean;
				if(null!=searchBean){
					sb.append(" where 1=1 ");
					if((null != searchBean) && (searchBean.getRuleId()!=0)){
						sb.append(" and RULE_ID="+searchBean.getRuleId()+" ");
					}
				}
			}
			
			
			else if (){
				
			}
		}
		return sb.toString();
	}

	public int getCountByFilterLineValuesByCondition(DimFilterLineBean dimFilterLineBean) throws SQLException {
		try {
			String strCondition = BuildCondition(dimFilterLineBean);
			StringBuffer sql = new StringBuffer();
			sql.append(" select count(1) from HAE_DIM_FILTER_LINE ");
			if ((null != strCondition) && (strCondition.length() > 0)) {
				sql.append(" where " + strCondition);
			}
			return ((Integer) this.namedjdbcTemplate.getJdbcOperations().queryForObject(sql.toString(), Integer.TYPE))
					.intValue();
		} catch (Exception e) {
			throw new SQLException(e);
		}
	}

	public List<DimensionValueBean> getDimensionValueByCondition(DimensionValueBean dimensionValueBean) {
		return null;
	}

	public int createFilterLineValues(DimFilterLineBean queryBean) {
		int primarykey = (int) getAutoGeneratedPrimaryKey("HAE_DIM_FILTER_LINE_S");
		queryBean.setFilterLineId(primarykey);
		String sql = "INSERT INTO HAE_DIM_FILTER_LINE (FILTER_LINE_ID,FILTER_HEADER_ID, VALUE_LOW,VALUE_HIGH,INC_EXC_INDICATOR,DESCRIPTION,CREATED_BY,CREATED_DATE,LAST_UPDATED_BY,LAST_UPDATED_DATE)VALUES(:filterLineId,:filterHeaderId,:valueLow,:valueHigh,:incExcIndicator,:description,:createdBy,:creationDate,:lastUpdatedBy,:lastUpdateDate )";

		System.out.println(sql);
		SqlParameterSource namedParameters = new BeanPropertySqlParameterSource(queryBean);
		this.namedjdbcTemplate.update(sql, namedParameters);
		return primarykey;
	}

	@Override
	public int updateFilterLineValues(DimFilterLineBean updateBean) throws SQLException {
		int updateNum = 0;
		try {
			StringBuffer sql = new StringBuffer();
			sql.append("UPDATE HAE_DIM_FILTER_LINE SET ");
			sql.append(" VALUE_LOW=NVL(:valueLow,VALUE_LOW),");
			sql.append(" VALUE_HIGH=NVL(:valueHigh,VALUE_HIGH),");
			sql.append(" INC_EXC_INDICATOR=NVL(:incExcIndicator,INC_EXC_INDICATOR),");
			sql.append(" DESCRIPTION=NVL(:description,DESCRIPTION),");
			sql.append(" LAST_UPDATED_BY =NVL(:lastUpdatedBy,LAST_UPDATED_BY),");
			sql.append(" LAST_UPDATED_DATE =NVL(:lastUpdateDate,LAST_UPDATED_DATE)");
			sql.append(" WHERE FILTER_LINE_ID=:filterLineId AND  FILTER_HEADER_ID=:filterHeaderId");
			SqlParameterSource namedParameters = new BeanPropertySqlParameterSource(updateBean);

			updateNum = this.namedjdbcTemplate.update(sql.toString(), namedParameters);
		} catch (Exception e) {
			throw new SQLException(e);
		}
		return updateNum;
	}

	@Override
	public int destroyFilterLineValues(DimFilterLineBean updateBean) throws SQLException {
		int deleteNum = 0;
		try {
			StringBuffer sql = new StringBuffer();
			sql.append("delete from HAE_DIM_FILTER_LINE");
			sql.append(" WHERE FILTER_LINE_ID=:filterLineId");
			SqlParameterSource namedParameters = new BeanPropertySqlParameterSource(updateBean);

			deleteNum = this.namedjdbcTemplate.update(sql.toString(), namedParameters);
		} catch (Exception e) {
			throw new SQLException(e);
		}
		return deleteNum;
	}

	// delete update create 使用该方法
	private int sqlExecution(StringBuffer sql, AuditBean2 conditionBean) throws SQLException {

		int returnnum = 0;
		SqlParameterSource namedParameters = new BeanPropertySqlParameterSource(conditionBean);
		returnnum = this.namedjdbcTemplate.update(sql.toString(), namedParameters);
		return returnnum;
	}
    //XXX driverStaticHeader
	
	 * driverStaticHeader
	 * 
	@Override
	public List<Map<String, Object>> findDriverStaticHeader(DriverStaticHeader conditionBean) throws SQLException {
		String strCondition = BuildCondition(conditionBean);
		StringBuffer sql = new StringBuffer();
		List<Map<String, Object>> list = null;
		try {
			sql.append("SELECT ");
			if ((conditionBean.getRowStartIndex() != 0) && (conditionBean.getRowCount() != 0)) {
				sql.append(
						" STATIC_HEADER_ID,DRIVER_CODE,DESCRIPTION,DIMENSION_SEGMENT,"
						+ "START_DATE_ACTIVE,END_DATE_ACTIVE,CREATED_BY,CREATED_DATE,"
						+ "LAST_UPDATED_BY,LAST_UPDATED_DATE,"
						+ "ROW_NUMBER() OVER (ORDER BY STATIC_HEADER_ID)  AS row_number");
			} else {
				sql.append(
						" STATIC_HEADER_ID,DRIVER_CODE,DESCRIPTION,DIMENSION_SEGMENT,"
						+ "START_DATE_ACTIVE,END_DATE_ACTIVE,CREATED_BY,CREATED_DATE,"
						+ "LAST_UPDATED_BY,LAST_UPDATED_DATE ");
			}
			sql.append(" from  HAE_DRIVER_STATIC_HEADER ");
			//if ((null != strCondition) && (strCondition.length() > 0)) {
				sql.append(strCondition);
			//}
			if ((conditionBean.getRowStartIndex() != 0) && (conditionBean.getRowCount() != 0)) {
				sql = pageSql(sql, conditionBean.getRowStartIndex(), conditionBean.getRowCount());
			}
			list = this.namedjdbcTemplate.getJdbcOperations().queryForList(sql.toString());
		} catch (Exception e) {
			throw new SQLException(e);
		}
		return list;
	}

	@Override
	public int getCountDriverStaticHeader(DriverStaticHeader conditionBean) throws SQLException {
		try {
			String strCondition = BuildCondition(conditionBean);
			StringBuffer sql = new StringBuffer();
			sql.append(" select count(1) from  HAE_DRIVER_STATIC_HEADER ");
			sql.append(strCondition);
			return ((Integer) this.namedjdbcTemplate.getJdbcOperations().queryForObject(sql.toString(), Integer.TYPE))
					.intValue();
		} catch (Exception e) {
			throw new SQLException(e);
		}
	}

	@Override
	public int createNewDriverStaticHeader(DriverStaticHeader createBean) throws SQLException {
		int primarykey = (int) getAutoGeneratedPrimaryKey("HAE_DRIVER_STATIC_HEADER_S");
		createBean.setStaticHeaderId(primarykey);
		StringBuffer sql = new StringBuffer();
        sql.append("insert into HAE_DRIVER_STATIC_HEADER"
        		+ "(STATIC_HEADER_ID,DRIVER_CODE,DESCRIPTION,DIMENSION_SEGMENT,"
        		+ "START_DATE_ACTIVE,END_DATE_ACTIVE,CREATED_BY,CREATED_DATE,LAST_UPDATED_BY,"
        		+ "LAST_UPDATED_DATE) values(:staticHeaderId,:driverCode,:description,:dimensionSegment,:startDateActive,"
        		+ ":endDateActive,:createdBy,:creationDate,:lastUpdatedBy,:lastUpdateDate)");
		return this.sqlExecution(sql, createBean);
	}

	@Override
	public int updateDriverStaticHeader(DriverStaticHeader updateBean) throws SQLException {
		StringBuffer sql = new StringBuffer();
		sql.append("UPDATE HAE_DRIVER_STATIC_HEADER SET ");
		sql.append(" DRIVER_CODE=NVL(:driverCode,DRIVER_CODE),");
		sql.append(" DESCRIPTION=NVL(:description,DESCRIPTION),");
		sql.append(" DIMENSION_SEGMENT=NVL(:dimensionSegment,DIMENSION_SEGMENT),");
		sql.append(" START_DATE_ACTIVE=NVL(:startDateActive,START_DATE_ACTIVE),");
		sql.append(" END_DATE_ACTIVE =NVL(:endDateActive,END_DATE_ACTIVE),");
		sql.append(" LAST_UPDATED_BY =NVL(:lastUpdatedBy,LAST_UPDATED_BY),");
		sql.append(" LAST_UPDATED_DATE =NVL(:lastUpdateDate,LAST_UPDATED_DATE)");
		sql.append(" WHERE STATIC_HEADER_ID=:staticHeaderId ");
		return this.sqlExecution(sql, updateBean);
	}

	@Override
	public int deleteDriverStaticHeader(DriverStaticHeader deleteBean) throws SQLException {
		StringBuffer sql = new StringBuffer();
		sql.append("delete from HAE_DRIVER_STATIC_HEADER");
		sql.append(" WHERE STATIC_HEADER_ID=:staticHeaderId ");
		int a=this.sqlExecution(sql, deleteBean);
		sql.delete(0, sql.length());
		sql.append("delete from HAE_DRIVER_STATIC_LINE");
		sql.append(" WHERE STATIC_HEADER_ID=:staticHeaderId ");
		int b=this.sqlExecution(sql, deleteBean);
		return a+b;
	}
    
	
	
	//XXX DriverStaticLine
	
	 * 	静态因子行
	 * 
	 
	@Override
	public DriverStaticHeader getDriverStaticHeaderById(int parentid) throws SQLException {
		StringBuffer sql = new StringBuffer();
		DriverStaticHeader result = null;
		try {
			sql.append("select ");
			sql.append(
					" STATIC_HEADER_ID,DRIVER_CODE,DESCRIPTION,DIMENSION_SEGMENT,"
							+ "START_DATE_ACTIVE,END_DATE_ACTIVE,CREATED_BY,CREATED_DATE,"
							+ "LAST_UPDATED_BY,LAST_UPDATED_DATE FROM HAE_DRIVER_STATIC_HEADER");
			sql.append(" WHERE STATIC_HEADER_ID=" + parentid);
			result = (DriverStaticHeader) this.namedjdbcTemplate.getJdbcOperations().queryForObject(sql.toString(),
					new DriverStaticHeaderMapper());
		} catch (Exception e) {
			throw new SQLException(e);
		}
		return result;
	}

	@Override
	public List<Map<String, Object>> getDriverStaticLine(DriverStaticLine conditionBean) throws SQLException {
		String strCondition = BuildCondition(conditionBean);
		StringBuffer sql = new StringBuffer();
		List<Map<String, Object>> list = null;
		try {
			sql.append("SELECT ");
			if ((conditionBean.getRowStartIndex() != 0) && (conditionBean.getRowCount() != 0)) {
				sql.append(
						" STATIC_LINE_ID,STATIC_HEADER_ID,DIM_VALUE,DRIVER_NAME,DESCRIPTION,"
						+ "PROPORTION,START_DATE_ACTIVE,END_DATE_ACTIVE,CREATED_BY,"
						+ "CREATED_DATE,LAST_UPDATED_BY,LAST_UPDATED_DATE,"
						+ "ROW_NUMBER() OVER (ORDER BY STATIC_LINE_ID)  AS row_number ");
			} else {
				sql.append(
						" STATIC_LINE_ID,STATIC_HEADER_ID,DIM_VALUE,DRIVER_NAME,DESCRIPTION,"
						+ "PROPORTION,START_DATE_ACTIVE,END_DATE_ACTIVE,CREATED_BY,"
						+ "CREATED_DATE,LAST_UPDATED_BY,LAST_UPDATED_DATE ");
			}
			sql.append(" from HAE_DRIVER_STATIC_LINE ");
			if ((null != strCondition) && (strCondition.length() > 0)) {
				sql.append(strCondition);
			}
			if ((conditionBean.getRowStartIndex() != 0) && (conditionBean.getRowCount() != 0)) {
				sql = pageSql(sql, conditionBean.getRowStartIndex(), conditionBean.getRowCount());
			}
			list = this.namedjdbcTemplate.getJdbcOperations().queryForList(sql.toString());
		} catch (Exception e) {
			throw new SQLException(e);
		}
		return list;
	}
   
	@Override
	public int getCountDriverStaticLine(DriverStaticLine conditionBean) throws SQLException {
		try {
			String strCondition = BuildCondition(conditionBean);
			StringBuffer sql = new StringBuffer();
			sql.append(" select count(1) from  HAE_DRIVER_STATIC_LINE ");
			sql.append(strCondition);
			return ((Integer) this.namedjdbcTemplate.getJdbcOperations().queryForObject(sql.toString(), Integer.TYPE))
					.intValue();
		} catch (Exception e) {
			throw new SQLException(e);
		}
	}

	@Override
	public int createDriverStaticLine(DriverStaticLine createBean) throws SQLException {
		int primarykey = (int) getAutoGeneratedPrimaryKey("HAE_DRIVER_STATIC_LINE_S");
		createBean.setStaticLineId(primarykey);
		StringBuffer sql = new StringBuffer();
		sql.append("insert into HAE_DRIVER_STATIC_LINE "
				+ "(STATIC_LINE_ID,STATIC_HEADER_ID,DIM_VALUE,DRIVER_NAME,DESCRIPTION,"
				+ "PROPORTION,START_DATE_ACTIVE,END_DATE_ACTIVE,CREATED_BY,"
				+ "CREATED_DATE,LAST_UPDATED_BY,LAST_UPDATED_DATE) values"
				+ " (:staticLineId,:staticHeaderId,:dimValue,:driverName,:description,:proportion,"
				+ ":startDateActive,:endDateActive,:createdBy,:creationDate,:lastUpdatedBy,:lastUpdateDate)");
		return this.sqlExecution(sql, createBean);
	}

	@Override
	public int updateDriverStaticLine(DriverStaticLine updateBean) throws SQLException {
		StringBuffer sql = new StringBuffer();
		sql.append("UPDATE HAE_DRIVER_STATIC_LINE SET ");
		sql.append(" STATIC_HEADER_ID=NVL(:staticHeaderId,STATIC_HEADER_ID),");
		sql.append(" DIM_VALUE=NVL(:dimValue,DIM_VALUE),");
		sql.append(" DRIVER_NAME=NVL(:driverName,DRIVER_NAME),");
		sql.append(" DESCRIPTION =NVL(:description,DESCRIPTION),");
		sql.append(" PROPORTION =NVL(:proportion,PROPORTION),");
		sql.append(" START_DATE_ACTIVE=NVL(:startDateActive,START_DATE_ACTIVE),");
		sql.append(" END_DATE_ACTIVE =NVL(:endDateActive,END_DATE_ACTIVE),");
		sql.append(" LAST_UPDATED_BY =NVL(:lastUpdatedBy,LAST_UPDATED_BY),");
		sql.append(" LAST_UPDATED_DATE =NVL(:lastUpdateDate,LAST_UPDATED_DATE)");
		sql.append(" WHERE STATIC_LINE_ID=:staticLineId ");
		return this.sqlExecution(sql, updateBean);
	}

	@Override
	public int deleteDriverStaticLine(DriverStaticLine destroyBean) throws SQLException {
		StringBuffer sql = new StringBuffer();
		sql.append("delete from HAE_DRIVER_STATIC_LINE");
		sql.append(" WHERE STATIC_LINE_ID=:staticLineId ");
		return  this.sqlExecution(sql, destroyBean);
	}

	
	//XXX AllocRulesGroupHaeader
	@Override
	public List<Map<String, Object>> findAllocRulesGroupHaeader(AllocRulesGroupHaeaderBean conditionBean)
			throws SQLException {
		String strCondition = BuildCondition(conditionBean);
		StringBuffer sql = new StringBuffer();
		List<Map<String, Object>> list = null;
		try {
			sql.append("SELECT ");
			if ((conditionBean.getRowStartIndex() != 0) && (conditionBean.getRowCount() != 0)) {
				sql.append(
						  " GROUP_HEADER_ID,GROUP_NUM,GROUP_NAME,START_DATE_ACTIVE,END_DATE_ACTIVE,DESCRIPTION,"
						  + "CREATED_BY,CREATED_DATE,UPDATED_BY,UPDATED_DATE, "
						+ "ROW_NUMBER() OVER (ORDER BY GROUP_HEADER_ID)  AS row_number");
			} else {
				sql.append(
						" GROUP_HEADER_ID,GROUP_NUM,GROUP_NAME,START_DATE_ACTIVE,END_DATE_ACTIVE,DESCRIPTION,"
						+ "CREATED_BY,CREATED_DATE,UPDATED_BY,UPDATED_DATE ");
			}
			sql.append("  FROM  HAE_ALLOC_RULES_GROUP_HAEADER ");
			//if ((null != strCondition) && (strCondition.length() > 0)) {
				sql.append(strCondition);
			//}
			if ((conditionBean.getRowStartIndex() != 0) && (conditionBean.getRowCount() != 0)) {
				sql = pageSql(sql, conditionBean.getRowStartIndex(), conditionBean.getRowCount());
			}
			sql.append(" order by GROUP_HEADER_ID");
			list = this.namedjdbcTemplate.getJdbcOperations().queryForList(sql.toString());
		} catch (Exception e) {
			throw new SQLException(e);
		}
		return list;
	}

	@Override
	public int getCountAllocRulesGroupHaeader(AllocRulesGroupHaeaderBean conditionBean) throws SQLException {
		try {
			String strCondition = BuildCondition(conditionBean);
			StringBuffer sql = new StringBuffer();
			sql.append(" select count(1) from  HAE_ALLOC_RULES_GROUP_HAEADER ");
			sql.append(strCondition);
			return ((Integer) this.namedjdbcTemplate.getJdbcOperations().queryForObject(sql.toString(), Integer.TYPE))
					.intValue();
		} catch (Exception e) {
			throw new SQLException(e);
		}
	}

	@Override
	public int createNewAllocRulesGroupHaeader(AllocRulesGroupHaeaderBean createBean) throws SQLException {
		int primarykey = (int) getAutoGeneratedPrimaryKey("HAE_ALLOC_RULES_GROUP_H_S");
		createBean.setGroupHeaderId(primarykey);
		StringBuffer sql = new StringBuffer();
        sql.append("insert into HAE_ALLOC_RULES_GROUP_HAEADER"
        		+ " (GROUP_HEADER_ID,GROUP_NUM,GROUP_NAME,START_DATE_ACTIVE,END_DATE_ACTIVE,DESCRIPTION,"
        		+ " CREATED_BY,CREATED_DATE,UPDATED_BY,UPDATED_DATE) values (:groupHeaderId,:groupNum,:groupName,"
        		+ " :startDateActive,:endDateActive,:description,:createdBy,:creationDate,:lastUpdatedBy,:lastUpdateDate)");
		return this.sqlExecution(sql, createBean);
	}

	@Override
	public int updateAllocRulesGroupHaeader(AllocRulesGroupHaeaderBean updateBean) throws SQLException {
		StringBuffer sql = new StringBuffer();
		sql.append("UPDATE HAE_ALLOC_RULES_GROUP_HAEADER SET ");
		sql.append(" GROUP_NUM=NVL(:groupNum,GROUP_NUM),");
		sql.append(" GROUP_NAME=NVL(:groupName,GROUP_NAME),");
		sql.append(" START_DATE_ACTIVE=NVL(:startDateActive,START_DATE_ACTIVE),");
		sql.append(" END_DATE_ACTIVE =NVL(:endDateActive,END_DATE_ACTIVE),");
		sql.append(" DESCRIPTION =NVL(:description,DESCRIPTION),");
		sql.append(" UPDATED_BY =NVL(:lastUpdatedBy,UPDATED_BY),");
		sql.append(" UPDATED_DATE =NVL(:lastUpdateDate,UPDATED_DATE)");
		sql.append(" WHERE GROUP_HEADER_ID=:groupHeaderId ");
		return this.sqlExecution(sql, updateBean);
	}

	@Override
	public int deleteAllocRulesGroupHaeader(AllocRulesGroupHaeaderBean deleteBean) throws SQLException {
		StringBuffer sql = new StringBuffer();
		sql.append("delete from HAE_ALLOC_RULES_GROUP_HAEADER");
		sql.append(" WHERE GROUP_HEADER_ID=:groupHeaderId ");
		int a=this.sqlExecution(sql, deleteBean);
		sql.delete(0, sql.length());
		sql.append("delete from HAE_ALLOC_RULES_GROUP_LINE");
		sql.append(" WHERE GROUP_HEADER_ID=:groupHeaderId ");
		int b=this.sqlExecution(sql, deleteBean);
		return a+b;
	}

	
	//XXX AllocRulesGroupLineBean
	@Override
	public AllocRulesGroupHaeaderBean getAllocRulesGroupHaeaderById(int parentid) throws SQLException {
		StringBuffer sql = new StringBuffer();
		AllocRulesGroupHaeaderBean result = null;
		try {
			sql.append("select ");
			sql.append(
					" GROUP_HEADER_ID,GROUP_NUM,GROUP_NAME,START_DATE_ACTIVE,END_DATE_ACTIVE,DESCRIPTION,"
							+ "CREATED_BY,CREATED_DATE,UPDATED_BY,UPDATED_DATE FROM HAE_ALLOC_RULES_GROUP_HAEADER");
			sql.append(" WHERE GROUP_HEADER_ID=" + parentid);
			result = (AllocRulesGroupHaeaderBean) this.namedjdbcTemplate.getJdbcOperations().queryForObject(sql.toString(),
					new AllocRulesGroupHaeaderMapper());
		} catch (Exception e) {
			throw new SQLException(e);
		}
		return result;
	}

	@Override
	public List<Map<String, Object>> findAllocRulesGroupLine(AllocRulesGroupLineBean conditionBean) throws SQLException {
		String strCondition = BuildCondition(conditionBean);
		StringBuffer sql = new StringBuffer();
		List<Map<String, Object>> list = null;
		try {
			sql.append("SELECT ");
			if ((conditionBean.getRowStartIndex() != 0) && (conditionBean.getRowCount() != 0)) {
				sql.append(
						" GROUP_LINE_ID,GROUP_HEADER_ID,LINE_NUM,RULE_ID,RULE_NAME,DRIVER_TYPE,"
						+ "DESCRIPTION,START_DATE_ACTIVE,END_DATE_ACTIVE, "
						+ "ROW_NUMBER() OVER (ORDER BY GROUP_LINE_ID)  AS row_number ");
			} else {
				sql.append(
						" GROUP_LINE_ID,GROUP_HEADER_ID,LINE_NUM,RULE_ID,RULE_NAME,DRIVER_TYPE,"
						+ "DESCRIPTION,START_DATE_ACTIVE,END_DATE_ACTIVE ");
			}
			sql.append(" from HAE_VIEW_GROUP_LINE  ");
			if ((null != strCondition) && (strCondition.length() > 0)) {
				sql.append(strCondition);
			}
			if ((conditionBean.getRowStartIndex() != 0) && (conditionBean.getRowCount() != 0)) {
				sql = pageSql(sql, conditionBean.getRowStartIndex(), conditionBean.getRowCount());
			}
			sql.append(" order by GROUP_LINE_ID ");
			list = this.namedjdbcTemplate.getJdbcOperations().queryForList(sql.toString());
		} catch (Exception e) {
			throw new SQLException(e);
		}
		return list;
	}

	@Override
	public int getCountAllocRulesGroupLine(AllocRulesGroupLineBean conditionBean) throws SQLException {
		try {
			String strCondition = BuildCondition(conditionBean);
			StringBuffer sql = new StringBuffer();
			sql.append(" select count(1) from  HAE_VIEW_GROUP_LINE ");
			sql.append(strCondition);
			return ((Integer) this.namedjdbcTemplate.getJdbcOperations().queryForObject(sql.toString(), Integer.TYPE))
					.intValue();
		} catch (Exception e) {
			throw new SQLException(e);
		}
	}

	@Override
	public int createAllocRulesGroupLine(AllocRulesGroupLineBean createBean) throws SQLException {
		int primarykey = (int) getAutoGeneratedPrimaryKey("HAE_ALLOC_RULES_GROUP_L_S");
		createBean.setGroupLineId(primarykey);
		StringBuffer sql = new StringBuffer();
		sql.append("insert into HAE_ALLOC_RULES_GROUP_LINE "
				+ "( GROUP_LINE_ID,GROUP_HEADER_ID,LINE_NUM,RULE_ID,CREATED_BY,CREATED_DATE,"
				+ "UPDATED_BY,UPDATED_DATE ) values (:groupLineId,"
				+ ":groupHeaderId,:lineNum,:ruleId,:createdBy,:creationDate,"
				+ ":lastUpdatedBy,:lastUpdateDate)");
		return this.sqlExecution(sql, createBean);
	}

	@Override
	public int updateAllocRulesGroupLine(AllocRulesGroupLineBean updateBean) throws SQLException {
		StringBuffer sql = new StringBuffer();
		sql.append("UPDATE HAE_ALLOC_RULES_GROUP_LINE SET ");
		sql.append(" GROUP_HEADER_ID=NVL(:groupHeaderId,GROUP_HEADER_ID),");
		sql.append(" LINE_NUM=NVL(:lineNum,LINE_NUM),");
		sql.append(" RULE_ID =NVL(:ruleId,RULE_ID),");
		sql.append(" UPDATED_BY =NVL(:lastUpdatedBy,UPDATED_BY),");
		sql.append(" UPDATED_DATE =NVL(:lastUpdateDate,UPDATED_DATE)");
		sql.append(" WHERE GROUP_LINE_ID=:groupLineId ");
		return this.sqlExecution(sql, updateBean);
	}

	@Override
	public int deleteAllocRulesGroupLine(AllocRulesGroupLineBean deleteBean) throws SQLException {
		StringBuffer sql = new StringBuffer();
		sql.append("delete from HAE_ALLOC_RULES_GROUP_LINE");
		sql.append(" WHERE GROUP_LINE_ID=:groupLineId ");
		return this.sqlExecution(sql, deleteBean);
		
	}

	//XXX AllocRuleBean

	@Override
	public List<Map<String, Object>> findAllocRule(AllocRuleBean conditionBean) throws SQLException {
		//SELECT RULE_ID,LINE_NUM,RULE_NAME,DRIVER_TYPE,START_DATE_ACTIVE,END_DATE_ACTIVE,SOURCE_ID,DRIVER_ID,TARGET_ID,OFFSET_ID,CREATED_BY,CREATED_DATE,UPDATED_BY,UPDATED_DATE FROM HAE_ALLOC_RULE 
		String strCondition = BuildCondition(conditionBean);
		StringBuffer sql = new StringBuffer();
		List<Map<String, Object>> list = null;
		try {
			sql.append("SELECT ");
			if ((conditionBean.getRowStartIndex() != 0) && (conditionBean.getRowCount() != 0)) {
				sql.append(
						  " RULE_ID,LINE_NUM,RULE_NAME,DRIVER_TYPE,DESCRIPTION,START_DATE_ACTIVE,END_DATE_ACTIVE,"
						  + "SOURCE_ID,DRIVER_ID,TARGET_ID,OFFSET_ID,CREATED_BY,CREATED_DATE,UPDATED_BY,UPDATED_DATE , "
						+ "ROW_NUMBER() OVER (ORDER BY RULE_ID)  AS row_number");
			} else {
				sql.append(
						  " RULE_ID,LINE_NUM,RULE_NAME,DRIVER_TYPE,DESCRIPTION,START_DATE_ACTIVE,END_DATE_ACTIVE,"
						  + "SOURCE_ID,DRIVER_ID,TARGET_ID,OFFSET_ID,CREATED_BY,CREATED_DATE,UPDATED_BY,UPDATED_DATE ");
			}
			sql.append(" FROM HAE_ALLOC_RULE  ");
			//if ((null != strCondition) && (strCondition.length() > 0)) {
				sql.append(strCondition);
			//}
			if ((conditionBean.getRowStartIndex() != 0) && (conditionBean.getRowCount() != 0)) {
				sql = pageSql(sql, conditionBean.getRowStartIndex(), conditionBean.getRowCount());
			}
			sql.append(" order by RULE_ID");
			list = this.namedjdbcTemplate.getJdbcOperations().queryForList(sql.toString());
		} catch (Exception e) {
			throw new SQLException(e);
		}
		return list;
	}

	@Override
	public int getCountAllocRule(AllocRuleBean conditionBean) throws SQLException {
		try {
			String strCondition = BuildCondition(conditionBean);
			StringBuffer sql = new StringBuffer();
			sql.append(" select count(1) from  HAE_ALLOC_RULE ");
			sql.append(strCondition);
			return ((Integer) this.namedjdbcTemplate.getJdbcOperations().queryForObject(sql.toString(), Integer.TYPE))
					.intValue();
		} catch (Exception e) {
			throw new SQLException(e);
		}
	}

	@Override
	public int createNewAllocRule(AllocRuleBean createBean) throws SQLException {
		int primarykey = (int) getAutoGeneratedPrimaryKey("HAE_ALLOC_RULE_S");
		createBean.setRuleId(primarykey);
		StringBuffer sql = new StringBuffer();
        sql.append("insert into HAE_ALLOC_RULE"
        		+ " (RULE_ID,LINE_NUM,RULE_NAME,DRIVER_TYPE,DESCRIPTION,START_DATE_ACTIVE,END_DATE_ACTIVE,SOURCE_ID,DRIVER_ID,"
        		+ "TARGET_ID,OFFSET_ID,CREATED_BY,CREATED_DATE,UPDATED_BY,UPDATED_DATE ) values (:ruleId,:lineNum,:ruleName,"
        		+ " :driverType,:description,:startDateActive,:endDateActive,:sourceId,:driverId,"
        		+ ":targetId,:offsetId,:createdBy,:creationDate,:lastUpdatedBy,:lastUpdateDate)");
		return this.sqlExecution(sql, createBean);
	}

	@Override
	public int updateAllocRule(AllocRuleBean updateBean) throws SQLException {
		StringBuffer sql = new StringBuffer();
		sql.append("UPDATE HAE_ALLOC_RULE SET ");
		sql.append(" LINE_NUM=NVL(:lineNum,LINE_NUM),");
		sql.append(" RULE_NAME=NVL(:ruleName,RULE_NAME),");
		sql.append(" DRIVER_TYPE=NVL(:driverType,DRIVER_TYPE),");
		sql.append(" START_DATE_ACTIVE=NVL(:startDateActive,START_DATE_ACTIVE),");
		sql.append(" END_DATE_ACTIVE =NVL(:endDateActive,END_DATE_ACTIVE),");
		sql.append("DESCRIPTION=NVL(:description,DESCRIPTION),");
		sql.append(" SOURCE_ID =NVL(:sourceId,SOURCE_ID),");
		sql.append(" DRIVER_ID =NVL(:driverId,DRIVER_ID),");
		sql.append(" TARGET_ID =NVL(:targetId,TARGET_ID),");
		sql.append(" OFFSET_ID =NVL(:offsetId,OFFSET_ID),");
		sql.append(" UPDATED_BY =NVL(:lastUpdatedBy,UPDATED_BY),");
		sql.append(" UPDATED_DATE =NVL(:lastUpdateDate,UPDATED_DATE)");
		sql.append(" WHERE RULE_ID=:ruleId ");
		return this.sqlExecution(sql, updateBean);
	}

	@Override
	public int deleteAllocRule(AllocRuleBean deleteBean) throws SQLException {
		//TODO 需要做级联删除，暂时只做当前表删除
		StringBuffer sql = new StringBuffer();
		sql.append("delete from HAE_ALLOC_RULE");
		sql.append(" WHERE RULE_ID=:ruleId ");
		return this.sqlExecution(sql, deleteBean);
	}

	

	@Override
	public AllocRuleBean getAllocRuleById(int parentid) throws SQLException {
		StringBuffer sql = new StringBuffer();
		AllocRuleBean result = null;
		try {
			sql.append("select ");
			sql.append(
					"  RULE_ID,LINE_NUM,RULE_NAME,DRIVER_TYPE,DESCRIPTION,START_DATE_ACTIVE,END_DATE_ACTIVE,"
						  + "SOURCE_ID,DRIVER_ID,TARGET_ID,OFFSET_ID,CREATED_BY,CREATED_DATE,UPDATED_BY,UPDATED_DATE  "
						  + "FROM HAE_ALLOC_RULE");
			sql.append(" WHERE RULE_ID=" + parentid);
			result = (AllocRuleBean) this.namedjdbcTemplate.getJdbcOperations().queryForObject(sql.toString(),
					new AllocRuleMapper());
		} catch (Exception e) {
			throw new SQLException(e);
		}
		return result;
	}
	
	
	//XXX AllocDriverAccountBean
	@Override
	public AllocDriverRecord getAllocDriverById(int parentid) throws SQLException {
		StringBuffer sql = new StringBuffer();
		AllocDriverRecord result = null;
		try {
			//SELECT DRIVER_ID,RULE_ID,DRIVER_TYPE,STATIC_HEADER_ID,CONSTANT,ACTUAL_FLAG,CURRENCY_TYPE,CURRENCY_CODE,AMOUNT_TYPE,DIRECTION_CODE,DESCRIPTION,CREATED_BY,CREATED_DATE,UPDATED_BY,UPDATED_DATE FROM HAE_ALLOC_DRIVER WHERE DRIVER_ID=
			sql.append("SELECT DRIVER_ID,RULE_ID,DRIVER_TYPE,STATIC_HEADER_ID,"
					+ "CONSTANT,ACTUAL_FLAG,CURRENCY_TYPE,CURRENCY_CODE,AMOUNT_TYPE,"
					+ "DIRECTION_CODE,DESCRIPTION,CREATED_BY,CREATED_DATE,UPDATED_BY,UPDATED_DATE "
					+ "FROM HAE_ALLOC_DRIVER WHERE DRIVER_ID="+parentid);
			result = (AllocDriverRecord) this.namedjdbcTemplate.getJdbcOperations().queryForObject(sql.toString(),
					new AllocDriverMapper());
		} catch (Exception e) {
			throw new SQLException(e);
		}
		return result;
	}
	
	@Override
	public List<Map<String, Object>> findAllocDriverAccount(AllocDriverAccountBean conditionBean) throws SQLException {
		String strCondition = BuildCondition(conditionBean);
		StringBuffer sql = new StringBuffer();
		List<Map<String, Object>> list = null;
		try {
			sql.append("SELECT  *  from ");
			if ((conditionBean.getRowStartIndex() != 0) && (conditionBean.getRowCount() != 0)) {
				sql.append(
						"(SELECT RESULTMAP.DRVIER_ACC_ID, RESULTMAP.DRVIER_ID, DIMSION.DIM_SEGMENT DIMENSION_SEGMENT, "
						+ "RESULTMAP.DIMENSION_VALUE, RESULTMAP.FILTER_HEADER_ID, RESULTMAP.DESCRIPTION, RESULTMAP.CREATED_BY, "
						+ "RESULTMAP.CREATED_DATE, RESULTMAP.UPDATED_BY, RESULTMAP.UPDATED_DATE , "
						+ "ROW_NUMBER()OVER(ORDER BY RESULTMAP.DRVIER_ACC_ID) ROW_NUMBER FROM ("
						+ " SELECT DRVIER_ACC_ID, DRVIER_ID, LEDGER_ID, FIN_ELEMENT, DIMENSION_SEGMENT, DIMENSION_VALUE, FILTER_HEADER_ID, "
						+ "DESCRIPTION, CREATED_BY, CREATED_DATE, UPDATED_BY, UPDATED_DATE FROM HAE_ALLOC_DRIVER_ACCOUNT) "
						+ "RESULTMAP RIGHT JOIN (SELECT DIM_SEGMENT, DIMENSION_NAME FROM HRS_CORE_DIMENSION UNION ALL "
						+ "SELECT 'LEDGER_ID' DIM_SEGMENT, '账套' DIMENSION_NAME FROM DUAL UNION ALL "
						+ "SELECT 'FIN_ELEMENT' DIM_SEGMENT,'财务要素' DIMENSION_NAME FROM DUAL) DIMSION "
						+ "ON RESULTMAP.DIMENSION_SEGMENT = DIMSION.DIM_SEGMENT )");
			} else {
				sql.append(
						"(SELECT RESULTMAP.DRVIER_ACC_ID, RESULTMAP.DRVIER_ID, DIMSION.DIM_SEGMENT DIMENSION_SEGMENT, "
						+ "RESULTMAP.DIMENSION_VALUE, RESULTMAP.FILTER_HEADER_ID, RESULTMAP.DESCRIPTION, RESULTMAP.CREATED_BY, "
						+ "RESULTMAP.CREATED_DATE, RESULTMAP.UPDATED_BY, RESULTMAP.UPDATED_DATE  "
						+ "FROM ("
						+ " SELECT DRVIER_ACC_ID, DRVIER_ID, LEDGER_ID, FIN_ELEMENT, DIMENSION_SEGMENT, DIMENSION_VALUE, FILTER_HEADER_ID, "
						+ "DESCRIPTION, CREATED_BY, CREATED_DATE, UPDATED_BY, UPDATED_DATE FROM HAE_ALLOC_DRIVER_ACCOUNT) "
						+ "RESULTMAP RIGHT JOIN (SELECT DIM_SEGMENT, DIMENSION_NAME FROM HRS_CORE_DIMENSION UNION ALL "
						+ "SELECT 'LEDGER_ID' DIM_SEGMENT, '账套' DIMENSION_NAME FROM DUAL UNION ALL "
						+ "SELECT 'FIN_ELEMENT' DIM_SEGMENT,'财务要素' DIMENSION_NAME FROM DUAL) DIMSION "
						+ "ON RESULTMAP.DIMENSION_SEGMENT = DIMSION.DIM_SEGMENT )");
			}
			if ((null != strCondition) && (strCondition.length() > 0)) {
				sql.append(strCondition);
			}
			if ((conditionBean.getRowStartIndex() != 0) && (conditionBean.getRowCount() != 0)) {
				sql = pageSql(sql, conditionBean.getRowStartIndex(), conditionBean.getRowCount());
			}
			sql.append(" order by DRVIER_ACC_ID ");
			list = this.namedjdbcTemplate.getJdbcOperations().queryForList(sql.toString());
		} catch (Exception e) {
			throw new SQLException(e);
		}
		return list;
	}



	@Override
	public int getCountAllocDriverAccount(AllocDriverAccountBean conditionBean) throws SQLException {
		try {
			String strCondition = BuildCondition(conditionBean);
			StringBuffer sql = new StringBuffer();
			sql.append(" select count(1) from  HAE_ALLOC_DRIVER_ACCOUNT ");
			sql.append(strCondition);
			return ((Integer) this.namedjdbcTemplate.getJdbcOperations().queryForObject(sql.toString(), Integer.TYPE))
					.intValue();
		} catch (Exception e) {
			throw new SQLException(e);
		}
	}

	@Override
	public int createAllocDriverAccount(AllocDriverAccountBean createBean) throws SQLException {
		int primarykey = (int) getAutoGeneratedPrimaryKey("HAE_ALLOC_DRIVER_ACCOUNT_S");
		createBean.setDrvierAccId(primarykey);
		StringBuffer sql = new StringBuffer();
		sql.append("insert into HAE_ALLOC_DRIVER_ACCOUNT  "
				+	" DRVIER_ACC_ID,DRVIER_ID,LEDGER_ID,FIN_ELEMENT,DIMENSION_SEGMENT,DIMENSION_VALUE,"
				+ "FILTER_HEADER_ID,DESCRIPTION,CREATED_BY,CREATED_DATE,UPDATED_BY,UPDATED_DATE "
				+ "values (:drvierAccId,:drvierId,:ledgerId,:finElement,:dimensionSegment,:dimensionValue,"
				+ ":filterHeaderId,:description,:createdBy,:creationDate,:lastUpdatedBy,:lastUpdateDate)");
		return this.sqlExecution(sql, createBean);
	}

	@Override
	public int updateAllocDriverAccount(AllocDriverAccountBean updateBean) throws SQLException {
		StringBuffer sql = new StringBuffer();
		sql.append("UPDATE HAE_ALLOC_DRIVER_ACCOUNT SET ");
		sql.append(" DRVIER_ACC_ID=NVL(:drvierAccId,DRVIER_ACC_ID),");
		sql.append(" DRVIER_ID=NVL(:drvierId,DRVIER_ID),");
		sql.append(" LEDGER_ID =NVL(:ledgerId,LEDGER_ID),");
		sql.append(" FIN_ELEMENT =NVL(:finElement,FIN_ELEMENT),");
		sql.append(" DIMENSION_SEGMENT =NVL(:dimensionSegment,DIMENSION_SEGMENT),");
		sql.append(" DIMENSION_VALUE =NVL(:dimensionValue,DIMENSION_VALUE),");
		sql.append(" FILTER_HEADER_ID =NVL(:filterHeaderId,FILTER_HEADER_ID),");
		sql.append(" DESCRIPTION =NVL(:description,DESCRIPTION),");
		sql.append(" UPDATED_BY =NVL(:lastUpdatedBy,UPDATED_BY),");
		sql.append(" UPDATED_DATE =NVL(:lastUpdateDate,UPDATED_DATE)");
		sql.append(" WHERE DRVIER_ACC_ID=:drvierAccId ");
		return this.sqlExecution(sql, updateBean);
	}


	
	
	@Override
	public List<Map<String, Object>> findAllocDriverAccount(AllocDriverAccountBean conditionBean) throws SQLException {
		StringBuffer sql = new StringBuffer();
		List<Map<String, Object>> list = null;
		int driverid=conditionBean.getDrvierId();
	
		sql.append(
				" SELECT RESULTMAP.DRVIER_ACC_ID, RESULTMAP.DRVIER_ID, RESULTMAP.LEDGER_ID, RESULTMAP.FIN_ELEMENT, DIM.DIM_SEGMENT DIMENSION_SEGMENT, DIM.DIMENSION_NAME, RESULTMAP.DIMENSION_VALUE,");
		sql.append(" RESULTMAP.FILTER_HEADER_ID, RESULTMAP.DESCRIPTION, RESULTMAP.CREATED_BY, RESULTMAP.CREATED_DATE,"
				+ " RESULTMAP.UPDATED_BY, RESULTMAP.UPDATED_DATE, ROW_NUMBER() OVER (ORDER BY DIM.DIM_SEGMENT)  AS row_number  from (SELECT DIM_SEGMENT, DIMENSION_NAME FROM HRS_CORE_DIMENSION UNION ALL SELECT 'LEDGER_ID' DIM_SEGMENT,"
				+ " '账套' DIMENSION_NAME FROM DUAL UNION ALL SELECT 'FIN_ELEMENT' DIM_SEGMENT, '财务要素' DIMENSION_NAME FROM DUAL) DIM LEFT JOIN (select DRVIER_ACC_ID, DRVIER_ID, LEDGER_ID, FIN_ELEMENT, "
				+ "DIMENSION_SEGMENT, DIMENSION_VALUE, FILTER_HEADER_ID, DESCRIPTION, CREATED_BY, CREATED_DATE, UPDATED_BY, UPDATED_DATE from hae_alloc_driver_account WHERE DRVIER_ID="
				+ driverid
				+  ") RESULTMAP"
				+ " ON DIM.DIM_SEGMENT = RESULTMAP.DIMENSION_SEGMENT");
		if ((conditionBean.getRowStartIndex() != 0) && (conditionBean.getRowCount() != 0)) {
			sql = pageSql(sql, conditionBean.getRowStartIndex(), conditionBean.getRowCount());
		}
		list = this.namedjdbcTemplate.getJdbcOperations().queryForList(sql.toString());
		return list;
	}

	@Override
	public int getCountAllocDriverAccount(AllocDriverAccountBean conditionBean) throws SQLException {
		try {
			String strCondition = BuildCondition(conditionBean);
			StringBuffer sql = new StringBuffer();
			sql.append(" select count(1) from HRS_CORE_DIMENSION ");
			sql.append(strCondition);
			 int result= ((Integer) this.namedjdbcTemplate.getJdbcOperations().queryForObject(sql.toString(), Integer.TYPE))
					.intValue();
			 return result+2;
		} catch (Exception e) {
			throw new SQLException(e);
		}
	}

	@Override
	public int createAllocDriverAccount(AllocDriverAccountBean createBean) throws SQLException {
		int primarykey = (int) getAutoGeneratedPrimaryKey("HAE_ALLOC_DRIVER_ACCOUNT_S");
		createBean.setDrvierAccId(primarykey);
		StringBuffer sql = new StringBuffer();
		sql.append("insert into hae_alloc_driver_account "
				+ "( DRVIER_ACC_ID,DRVIER_ID,LEDGER_ID,FIN_ELEMENT,DIMENSION_SEGMENT,DIMENSION_VALUE,"
				+ "FILTER_HEADER_ID,DESCRIPTION,CREATED_BY,CREATED_DATE,"
				+ "UPDATED_BY,UPDATED_DATE ) values (:drvierAccId,"
				+ ":drvierId,:ledgerId,:finElement,:dimensionSegment,");
		if(StringUtils.isBlank(createBean.getDimensionValue())){
			sql.append("null,");
		}else{
			sql.append(":dimensionValue,");
		}
		if(createBean.getFilterHeaderId()==0){
			sql.append("null,");
		}else{
			sql.append( ":filterHeaderId,");
		}
			sql.append( ":description,:createdBy,:creationDate,"
				+ ":lastUpdatedBy,:lastUpdateDate)");
		return this.sqlExecution(sql, createBean);
	}

	@Override
	public int updateAllocDriverAccount(AllocDriverAccountBean updateBean) throws SQLException {
		StringBuffer sql = new StringBuffer();
		sql.append("UPDATE hae_alloc_driver_account SET ");
		sql.append(" DRVIER_ID=NVL(:drvierId,DRVIER_ID),");
		sql.append(" LEDGER_ID =NVL(:ledgerId,LEDGER_ID),");
		sql.append(" FIN_ELEMENT =NVL(:finElement,FIN_ELEMENT),");
		sql.append(" DIMENSION_SEGMENT =NVL(:dimensionSegment,DIMENSION_SEGMENT),");
		if(StringUtils.isBlank(updateBean.getDimensionValue())){
			sql.append(" DIMENSION_VALUE =null,");
		}else{
			sql.append(" DIMENSION_VALUE =NVL(:dimensionValue,DIMENSION_VALUE),");
		}
		if(updateBean.getFilterHeaderId()==0){
			sql.append(" FILTER_HEADER_ID =null,");
		}else{
			sql.append(" FILTER_HEADER_ID =NVL(:filterHeaderId,FILTER_HEADER_ID),");
		}
		sql.append(" DESCRIPTION =NVL(:description,DESCRIPTION),");
		sql.append(" UPDATED_BY =NVL(:lastUpdatedBy,UPDATED_BY),");
		sql.append(" UPDATED_DATE =NVL(:lastUpdateDate,UPDATED_DATE)");
		sql.append(" WHERE DRVIER_ACC_ID=:drvierAccId ");
		return this.sqlExecution(sql, updateBean);
	}

	@Override
	public int deleteAllocDriverAccount(AllocDriverAccountBean deleteBean) throws SQLException {
		StringBuffer sql = new StringBuffer();
		sql.append("delete from HAE_ALLOC_DRIVER_ACCOUNT");
		sql.append(" WHERE DRVIER_ACC_ID=:drvierAccId ");
		return this.sqlExecution(sql, deleteBean);
	}
	
	

	
	//XXX AllocSourceBean
	@Override
	public List<Map<String, Object>> findAllocSource(AllocSourceBean conditionBean) throws SQLException {
		//SELECT RULE_ID,LINE_NUM,RULE_NAME,DRIVER_TYPE,START_DATE_ACTIVE,END_DATE_ACTIVE,SOURCE_ID,DRIVER_ID,TARGET_ID,OFFSET_ID,CREATED_BY,CREATED_DATE,UPDATED_BY,UPDATED_DATE FROM HAE_ALLOC_RULE 
		String strCondition = BuildCondition(conditionBean);
		StringBuffer sql = new StringBuffer();
		List<Map<String, Object>> list = null;
		try {
			sql.append("SELECT ");
			if ((conditionBean.getRowStartIndex() != 0) && (conditionBean.getRowCount() != 0)) {
				sql.append(
						  " SOURCE_ID,RULE_ID,SOURCE_TYPE,CONSTANT,ACTUAL_FLAG,CURRENCY_TYPE,CURRENCY_CODE,AMOUNT_TYPE,DIRECTION_CODE,OPERATOR,DESCRIPTION  ,"
						  + "CREATED_BY, CREATED_DATE,UPDATED_BY,UPDATED_DATE,"
						+ "ROW_NUMBER() OVER (ORDER BY SOURCE_ID)  AS row_number");
			} else {
				sql.append(
						  "SOURCE_ID,RULE_ID,SOURCE_TYPE,CONSTANT,ACTUAL_FLAG,CURRENCY_TYPE,CURRENCY_CODE,AMOUNT_TYPE,DIRECTION_CODE,OPERATOR,DESCRIPTION  ,"
						  + "CREATED_BY, CREATED_DATE,UPDATED_BY,UPDATED_DATE");
			}
			sql.append(" FROM HAE_ALLOC_SOURCE  ");
			//if ((null != strCondition) && (strCondition.length() > 0)) {
				sql.append(strCondition);
			//}
			if ((conditionBean.getRowStartIndex() != 0) && (conditionBean.getRowCount() != 0)) {
				sql = pageSql(sql, conditionBean.getRowStartIndex(), conditionBean.getRowCount());
			}
			sql.append(" order by SOURCE_ID");
			list = this.namedjdbcTemplate.getJdbcOperations().queryForList(sql.toString());
		} catch (Exception e) {
			throw new SQLException(e);
		}
		return list;
	}

	@Override
	public int getCountAllocSource(AllocSourceBean conditionBean) throws SQLException {
		try {
			String strCondition = BuildCondition(conditionBean);
			StringBuffer sql = new StringBuffer();
			sql.append(" select count(1) from  HAE_ALLOC_SOURCE ");
			sql.append(strCondition);
			return ((Integer) this.namedjdbcTemplate.getJdbcOperations().queryForObject(sql.toString(), Integer.TYPE))
					.intValue();
		} catch (Exception e) {
			throw new SQLException(e);
		}
	}

	@Override
	public int createAllocSource(AllocSourceBean createBean) throws SQLException {
		int primarykey = (int) getAutoGeneratedPrimaryKey("HAE_ALLOC_SOURCE_S");
		createBean.setSourceId(primarykey);
		StringBuffer sql = new StringBuffer();
		sql.append("insert into HAE_ALLOC_SOURCE "
				+ "( SOURCE_ID,RULE_ID,SOURCE_TYPE,CONSTANT,ACTUAL_FLAG,CURRENCY_TYPE,"
				+ "CURRENCY_CODE,AMOUNT_TYPE,DIRECTION_CODE,OPERATOR,DESCRIPTION,CREATED_BY,CREATED_DATE,"
				+ "UPDATED_BY,UPDATED_DATE ) values (:sourceId,"
				+ ":ruleId,:sourceType,:constant,:actualFlag,:currencyType,:currencyCode,:amountType,:directionCode,:operator,:description,:createdBy,:creationDate,"
				+ ":lastUpdatedBy,:lastUpdateDate)");
		return this.sqlExecution(sql, createBean);
	}

	@Override
	public int updateAllocSource(AllocSourceBean updateBean) throws SQLException {
		StringBuffer sql = new StringBuffer();
		sql.append("UPDATE HAE_ALLOC_SOURCE SET ");
		sql.append(" RULE_ID=NVL(:ruleId,RULE_ID),");
		sql.append(" SOURCE_TYPE =NVL(:sourceType,SOURCE_TYPE),");
		sql.append(" CONSTANT =NVL(:constant,CONSTANT),");
		sql.append(" ACTUAL_FLAG =NVL(:actualFlag,ACTUAL_FLAG),");
		sql.append(" CURRENCY_TYPE =NVL(:currencyType,CURRENCY_TYPE),");
		sql.append(" CURRENCY_CODE =NVL(:currencyCode,CURRENCY_CODE),");
		sql.append(" AMOUNT_TYPE =NVL(:amountType,AMOUNT_TYPE),");
		sql.append(" DIRECTION_CODE =NVL(:directionCode,DIRECTION_CODE),");
		sql.append(" OPERATOR =NVL(:operator,OPERATOR),");
		sql.append(" DESCRIPTION =NVL(:description,DESCRIPTION),");
		sql.append(" UPDATED_BY =NVL(:lastUpdatedBy,UPDATED_BY),");
		sql.append(" UPDATED_DATE =NVL(:lastUpdateDate,UPDATED_DATE)");
		sql.append(" WHERE SOURCE_ID=:sourceId ");
		return this.sqlExecution(sql, updateBean);
	}

	@Override
	public int deleteAllocSource(AllocSourceBean destroyBean) throws SQLException {
		StringBuffer sql = new StringBuffer();
		sql.append("delete from HAE_ALLOC_SOURCE");
		sql.append(" WHERE SOURCE_ID=:sourceId ");
		return this.sqlExecution(sql, destroyBean);
	}

	
	//XXX AllocSourceAccountBean
	@Override
	public AllocSourceBean getAllocSourceById(int parentid) throws SQLException {
		StringBuffer sql = new StringBuffer();
		AllocSourceBean result = null;
		try {
			//SELECT SOURCE_ID,RULE_ID,SOURCE_TYPE,CONSTANT,ACTUAL_FLAG,CURRENCY_TYPE,CURRENCY_CODE,AMOUNT_TYPE,DIRECTION_CODE,OPERATOR,DESCRIPTION,CREATED_BY,CREATED_DATE,UPDATED_BY,UPDATED_DATE FROM HAE_ALLOC_SOURCE WHERE SOURCE_ID=
			sql.append("select ");
			sql.append(
					" SOURCE_ID,RULE_ID,SOURCE_TYPE,CONSTANT,ACTUAL_FLAG,CURRENCY_TYPE,CURRENCY_CODE,AMOUNT_TYPE,"
					+ "DIRECTION_CODE,OPERATOR,DESCRIPTION,CREATED_BY,CREATED_DATE,UPDATED_BY,UPDATED_DATE ");
			sql.append(" from HAE_ALLOC_SOURCE  WHERE SOURCE_ID=" + parentid);
			result = (AllocSourceBean) this.namedjdbcTemplate.getJdbcOperations().queryForObject(sql.toString(),
					new AllocSourceMapper());
		} catch (Exception e) {
			throw new SQLException(e);
		}
		return result;
	}
	
	@Override
	public List<Map<String, Object>> findAllocSourceAccount(AllocSourceAccountBean conditionBean) throws SQLException {
		StringBuffer sql = new StringBuffer();
		List<Map<String, Object>> list = null;
		int sourceid=conditionBean.getSourceId();
	
		sql.append(
				" SELECT RESULTMAP.SOURCE_ACC_ID, RESULTMAP.SOURCE_ID, RESULTMAP.LEDGER_ID, RESULTMAP.FIN_ELEMENT, DIM.DIM_SEGMENT DIMENSION_SEGMENT, DIM.DIMENSION_NAME, RESULTMAP.DIMENSION_VALUE,");
		
		sql.append(" (CASE WHEN DIM.DIM_SEGMENT = 'LEDGER_ID' OR DIM.DIM_SEGMENT = 'FIN_ELEMENT' THEN ");
		sql.append("     (SELECT LV.DESCRIPTION FROM HRS_CORE_LOOKUP_VALUE LV, HRS_CORE_LOOKUP_TYPE L WHERE LV.LOOKUP_TYPE_ID = L.LOOKUP_TYPE_ID AND L.LOOKUP_TYPE = DIM.DIM_SEGMENT AND LV.LOOKUP_VALUE = RESULTMAP.DIMENSION_VALUE) ");
		sql.append("    ELSE (SELECT DV.DESCRIPTION FROM HRS_CORE_DIMENSION_VALUE DV, HRS_CORE_DIMENSION D WHERE DV.DIMENSION_ID = D.DIMENSION_ID AND D.DIM_SEGMENT = DIM.DIM_SEGMENT AND DV.DIM_VALUE = RESULTMAP.DIMENSION_VALUE)");
		sql.append("  END ) DIMENSION_VALUE_DES, ");
		sql.append(" RESULTMAP.FILTER_HEADER_ID, RESULTMAP.DESCRIPTION, RESULTMAP.CREATED_BY, RESULTMAP.CREATED_DATE,"
				+ " RESULTMAP.UPDATED_BY, RESULTMAP.UPDATED_DATE, ROW_NUMBER() OVER (ORDER BY DIM.DIM_SEGMENT)  AS row_number  from (SELECT DIM_SEGMENT, DIMENSION_NAME FROM HRS_CORE_DIMENSION UNION ALL SELECT 'LEDGER_ID' DIM_SEGMENT,"
				+ " '账套' DIMENSION_NAME FROM DUAL UNION ALL SELECT 'FIN_ELEMENT' DIM_SEGMENT, '财务要素' DIMENSION_NAME FROM DUAL) DIM LEFT JOIN (select SOURCE_ACC_ID, SOURCE_ID, LEDGER_ID, FIN_ELEMENT, "
				+ "DIMENSION_SEGMENT, DIMENSION_VALUE, FILTER_HEADER_ID, DESCRIPTION, CREATED_BY, CREATED_DATE, UPDATED_BY, UPDATED_DATE from hae_alloc_source_account WHERE SOURCE_ID="
				+ sourceid
				+  ") RESULTMAP"
				+ " ON DIM.DIM_SEGMENT = RESULTMAP.DIMENSION_SEGMENT");
		if ((conditionBean.getRowStartIndex() != 0) && (conditionBean.getRowCount() != 0)) {
			sql = pageSql(sql, conditionBean.getRowStartIndex(), conditionBean.getRowCount());
		}
		list = this.namedjdbcTemplate.getJdbcOperations().queryForList(sql.toString());
		return list;
	}
	
	@Override
	public int getCountAllocSourceAccount(AllocSourceAccountBean conditionBean) throws SQLException {
		try {
			String strCondition = BuildCondition(conditionBean);
			StringBuffer sql = new StringBuffer();
			sql.append(" select count(1) from HRS_CORE_DIMENSION ");
			sql.append(strCondition);
			 int result= ((Integer) this.namedjdbcTemplate.getJdbcOperations().queryForObject(sql.toString(), Integer.TYPE))
					.intValue();
			 return result+2;
		} catch (Exception e) {
			throw new SQLException(e);
		}
	}

	@Override
	public int createAllocSourceAccount(AllocSourceAccountBean createBean) throws SQLException {
		int primarykey = (int) getAutoGeneratedPrimaryKey("HAE_ALLOC_SOURCE_ACCOUNT_S");
		createBean.setSourceAccId(primarykey);
		StringBuffer sql = new StringBuffer();
		sql.append("insert into HAE_ALLOC_SOURCE_ACCOUNT "
				+ "( SOURCE_ACC_ID,SOURCE_ID,LEDGER_ID,FIN_ELEMENT,DIMENSION_SEGMENT,DIMENSION_VALUE,"
				+ "FILTER_HEADER_ID,DESCRIPTION,CREATED_BY,CREATED_DATE,"
				+ "UPDATED_BY,UPDATED_DATE ) values (:sourceAccId,"
				+ ":sourceId,:ledgerId,:finElement,:dimensionSegment,");
		if(StringUtils.isBlank(createBean.getDimensionValue())){
			sql.append("null,");
		}else{
			sql.append(":dimensionValue,");
		}
		if(createBean.getFilterHeaderId()==0){
			sql.append("null,");
		}else{
			sql.append( ":filterHeaderId,");
		}
			sql.append( ":description,:createdBy,:creationDate,"
				+ ":lastUpdatedBy,:lastUpdateDate)");
		return this.sqlExecution(sql, createBean);
	}

	@Override
	public int updateAllocSourceAccount(AllocSourceAccountBean updateBean) throws SQLException {
		StringBuffer sql = new StringBuffer();
		sql.append("UPDATE HAE_ALLOC_SOURCE_ACCOUNT SET ");
		sql.append(" SOURCE_ID=NVL(:sourceId,SOURCE_ID),");
		sql.append(" LEDGER_ID =NVL(:ledgerId,LEDGER_ID),");
		sql.append(" FIN_ELEMENT =NVL(:finElement,FIN_ELEMENT),");
		sql.append(" DIMENSION_SEGMENT =NVL(:dimensionSegment,DIMENSION_SEGMENT),");
		if(StringUtils.isBlank(updateBean.getDimensionValue())){
			sql.append(" DIMENSION_VALUE =null,");
		}else{
			sql.append(" DIMENSION_VALUE =NVL(:dimensionValue,DIMENSION_VALUE),");
		}
		if(updateBean.getFilterHeaderId()==0){
			sql.append(" FILTER_HEADER_ID =null,");
		}else{
			sql.append(" FILTER_HEADER_ID =NVL(:filterHeaderId,FILTER_HEADER_ID),");
		}
		sql.append(" DESCRIPTION =NVL(:description,DESCRIPTION),");
		sql.append(" UPDATED_BY =NVL(:lastUpdatedBy,UPDATED_BY),");
		sql.append(" UPDATED_DATE =NVL(:lastUpdateDate,UPDATED_DATE)");
		sql.append(" WHERE SOURCE_ACC_ID=:sourceAccId ");
		return this.sqlExecution(sql, updateBean);
	}

	
	//XXX AllocTargetAccountBean
	@Override
	public AllocTargetRecord getAllocTargetById(int parentid) throws SQLException {
		StringBuffer sql = new StringBuffer();
		AllocTargetRecord result = null;
		try {
			//   SELECT  TARGET_ID,  RULE_ID,  TYPE,  ACTUAL_FLAG,  CURRENCY_TYPE,  CURRENCY_CODE,  AMOUNT_TYPE,  DIRECTION_CODE,  DESCRIPTION,  CREATED_BY,  CREATED_DATE,  UPDATED_BY,  UPDATED_DATE FROM HAE_ALLOC_TARGET WHERE TARGET_ID=1003            
			sql.append("SELECT  TARGET_ID,  RULE_ID,  TYPE,  ACTUAL_FLAG,  CURRENCY_TYPE,  CURRENCY_CODE,  AMOUNT_TYPE, "
					+ " DIRECTION_CODE,  DESCRIPTION,  CREATED_BY,  CREATED_DATE,  UPDATED_BY,  UPDATED_DATE "
					+ "FROM HAE_ALLOC_TARGET WHERE TARGET_ID="+parentid);

			result = (AllocTargetRecord) this.namedjdbcTemplate.getJdbcOperations().queryForObject(sql.toString(),
					new AllocTargetMapper());
		} catch (Exception e) {
			throw new SQLException(e);
		}
		return result;
	}

	@Override
	public List<Map<String, Object>> findAllocTargetAccount(AllocTargetAccountBean conditionBean) throws SQLException {
		StringBuffer sql = new StringBuffer();
		List<Map<String, Object>> list = null;
		long targetid=conditionBean.getTargetId();
		
		sql.append("SELECT DIM.DIM_SEGMENT DIMENSION_SEGMENT, DIM.DIMENSION_NAME, RESULTMAP.TARGET_ACC_ID, "
				+ "RESULTMAP.TARGET_ID, RESULTMAP.LEDGER_ID, RESULTMAP.FIN_ELEMENT,  "
				+ "RESULTMAP.DIM_ALLOC_TYPE, RESULTMAP.DIMENSION_VALUE, RESULTMAP.DESCRIPTION, "
				+ "RESULTMAP.CREATED_BY, RESULTMAP.CREATED_DATE, RESULTMAP.UPDATED_BY, RESULTMAP.UPDATED_DATE, "
				+ "ROW_NUMBER() OVER(ORDER BY DIM.DIM_SEGMENT) AS ROW_NUMBER FROM (SELECT DIM_SEGMENT, DIMENSION_NAME "
				+ "FROM HRS_CORE_DIMENSION UNION ALL SELECT 'LEDGER_ID' DIM_SEGMENT, '账套' DIMENSION_NAME FROM DUAL "
				+ "UNION ALL SELECT 'FIN_ELEMENT' DIM_SEGMENT, '财务要素' DIMENSION_NAME FROM DUAL) DIM LEFT JOIN ("
				+ "SELECT TARGET_ACC_ID, TARGET_ID, LEDGER_ID, FIN_ELEMENT, DIMENSION_SEGMENT, DIM_ALLOC_TYPE, DIMENSION_VALUE, "
				+ "DESCRIPTION, CREATED_BY, CREATED_DATE, UPDATED_BY, UPDATED_DATE FROM HAE_ALLOC_TARGET_ACCOUNT WHERE "
				+ "TARGET_ID = "
				+ targetid
				+ ") RESULTMAP ON DIM.DIM_SEGMENT = RESULTMAP.DIMENSION_SEGMENT");
		if ((conditionBean.getRowStartIndex() != 0) && (conditionBean.getRowCount() != 0)) {

			sql = pageSql(sql, conditionBean.getRowStartIndex(), conditionBean.getRowCount());
		}
		list = this.namedjdbcTemplate.getJdbcOperations().queryForList(sql.toString());
		return list;
	}

	@Override
	public int getCountAllocTargetAccount(AllocTargetAccountBean conditionBean) throws SQLException {
		try {
			String strCondition = BuildCondition(conditionBean);
			StringBuffer sql = new StringBuffer();
			sql.append(" select count(1) from HRS_CORE_DIMENSION ");
			sql.append(strCondition);
			 int result= ((Integer) this.namedjdbcTemplate.getJdbcOperations().queryForObject(sql.toString(), Integer.TYPE))
					.intValue();
			 return result+2;
		} catch (Exception e) {
			throw new SQLException(e);
		}
	}

	@Override
	public int createNewAllocTargetAccount(AllocTargetAccountBean createBean) throws SQLException {
		int primarykey = (int) getAutoGeneratedPrimaryKey("HAE_ALLOC_TARGET_ACCOUNT_S");
		createBean.setTargetAccId(primarykey);
		StringBuffer sql = new StringBuffer();
		sql.append(" INSERT INTO HAE_ALLOC_TARGET_ACCOUNT ( "
				+ "TARGET_ACC_ID, TARGET_ID, LEDGER_ID, FIN_ELEMENT, DIMENSION_SEGMENT, DIM_ALLOC_TYPE, DIMENSION_VALUE,"
				+ " DESCRIPTION, CREATED_BY, CREATED_DATE, UPDATED_BY, UPDATED_DATE) VALUES"
				+ " (:targetAccId,:targetId,:ledgerId,:finElement,:dimensionSegment,:dimAllocType,:dimensionValue,"
				+ ":description,:createdBy,:creationDate,:lastUpdatedBy,:lastUpdateDate)");
		return this.sqlExecution(sql, createBean);
	}

	@Override
	public int updateAllocTargetAccount(AllocTargetAccountBean updateBean) throws SQLException {
		StringBuffer sql = new StringBuffer();
		sql.append("UPDATE HAE_ALLOC_TARGET_ACCOUNT SET ");
		sql.append(" TARGET_ID=NVL(:targetId,TARGET_ID),");
		sql.append(" LEDGER_ID =NVL(:ledgerId,LEDGER_ID),");
		sql.append(" FIN_ELEMENT =NVL(:finElement,FIN_ELEMENT),");
		sql.append(" DIMENSION_SEGMENT =NVL(:dimensionSegment,DIMENSION_SEGMENT),");
		sql.append(" DIMENSION_VALUE =NVL(:dimensionValue,DIMENSION_VALUE),");
		sql.append(" DIM_ALLOC_TYPE =NVL(:dimAllocType,DIM_ALLOC_TYPE),");
		sql.append(" DESCRIPTION =NVL(:description,DESCRIPTION),");
		sql.append(" UPDATED_BY =NVL(:lastUpdatedBy,UPDATED_BY),");
		sql.append(" UPDATED_DATE =NVL(:lastUpdateDate,UPDATED_DATE)");
		sql.append(" WHERE TARGET_ACC_ID=:targetAccId ");
		return this.sqlExecution(sql, updateBean);
	}

	public List<Map<String, Object>> getDimFilterListForCombo(DimFilterHeaderBean dfh) {
		StringBuffer sql = new StringBuffer();
		List<Map<String, Object>> list = null;
		String condition = "";
		sql.append(
				"SELECT FILTER_HEADER_ID, FILTER_HEADER_NAME, DIMENSION_SEGMENT, TYPE, DESCRIPTION, (FILTER_HEADER_NAME || '-' || DESCRIPTION) AS FILTER_DISP FROM hae_dim_filter_header ");
		if (dfh != null) {
			if (dfh.getFilterHeaderId() != 0) {
				condition = " WHERE FILTER_HEADER_ID = " + dfh.getFilterHeaderId();
			} else {
				if (!StringUtil.isEmptyTrim(dfh.getDimensionSegment())) {
					condition = " WHERE DIMENSION_SEGMENT='" + dfh.getDimensionSegment() + "' ";
				}
			}
		}

		sql.append(condition);
		
		list = this.namedjdbcTemplate.getJdbcOperations().queryForList(sql.toString());
		return list;
	}

	@Override
	public List<Map<String, Object>> findAllType(long allocRuleId) {
		StringBuffer sql = new StringBuffer();
		List<Map<String, Object>> list = null;
		sql.append("SELECT D.DRIVER_TYPE,S.SOURCE_TYPE,"
				+ "(SELECT SH.DIMENSION_SEGMENT  FROM HAE_DRIVER_STATIC_HEADER SH WHERE SH.STATIC_HEADER_ID=D.STATIC_HEADER_ID)STATIC_DIMENSION_SEGMENT, "
				+ "D.RULE_ID FROM HAE_ALLOC_DRIVER D,HAE_ALLOC_SOURCE S "
				+ "WHERE D.RULE_ID=S.RULE_ID  and  D.RULE_ID="+allocRuleId);
		list = this.namedjdbcTemplate.getJdbcOperations().queryForList(sql.toString());
		return list;
	}

	@Override
	public boolean existvaild(AuditBean2 createBean) throws SQLException {
		boolean isexist=false;
		String sql=null;
		int num=0;
		if(createBean!=null){
			if(createBean instanceof AllocTargetAccountBean){
				AllocTargetAccountBean queryBean=(AllocTargetAccountBean)createBean;
				sql="select COUNT(1) NUM from HAE_ALLOC_TARGET_ACCOUNT where TARGET_ID= "+queryBean.getTargetId()+"  and DIMENSION_SEGMENT='"+queryBean.getDimensionSegment() +"'";
			     num= ((Integer) this.namedjdbcTemplate.getJdbcOperations().queryForObject(sql.toString(), Integer.TYPE))
						.intValue();
			}
			if(createBean instanceof AllocSourceAccountBean){
				AllocSourceAccountBean queryBean=(AllocSourceAccountBean)createBean;
				sql="select COUNT(1) NUM from HAE_ALLOC_SOURCE_ACCOUNT where SOURCE_ID= "+queryBean.getSourceId()+"  and DIMENSION_SEGMENT='"+queryBean.getDimensionSegment() +"'";
			     num= ((Integer) this.namedjdbcTemplate.getJdbcOperations().queryForObject(sql.toString(), Integer.TYPE))
						.intValue();
			}
			if(createBean instanceof AllocDriverAccountBean){
				AllocDriverAccountBean queryBean=(AllocDriverAccountBean)createBean;
				sql="select COUNT(1) NUM from HAE_ALLOC_DRIVER_ACCOUNT where DRVIER_ID= "+queryBean.getDrvierId()+"  and DIMENSION_SEGMENT='"+queryBean.getDimensionSegment() +"'";
			     num= ((Integer) this.namedjdbcTemplate.getJdbcOperations().queryForObject(sql.toString(), Integer.TYPE))
						.intValue();
			}
		}
		if(num>0){
			isexist=true;
		}
		return isexist;
	}

	@Override
	public int getCountAllocSourceAccountTrue(AllocSourceAccountBean requestBean) throws SQLException {
		try {
			StringBuffer sql = new StringBuffer();
			sql.append(" select count(1) from hae_alloc_source_account  where source_id= "+requestBean.getSourceId());
			 int result= ((Integer) this.namedjdbcTemplate.getJdbcOperations().queryForObject(sql.toString(), Integer.TYPE))
					.intValue();
			 return result;
		} catch (Exception e) {
			throw new SQLException(e);
		}
	}

	@Override
	public int getCountAllocDriverAccountTrue(AllocDriverAccountBean requestBean) throws SQLException {
		try {
			StringBuffer sql = new StringBuffer();
			sql.append(" SELECT count(1) FROM HAE_ALLOC_DRIVER_ACCOUNT  where drvier_id="+requestBean.getDrvierId());
			 int result= ((Integer) this.namedjdbcTemplate.getJdbcOperations().queryForObject(sql.toString(), Integer.TYPE))
					.intValue();
			 return result;
		} catch (Exception e) {
			throw new SQLException(e);
		}
	}

	

	@Override
	public int getCountAllocTargetAccountTrue(AllocTargetAccountBean requestBean) throws SQLException {
		try {
			StringBuffer sql = new StringBuffer();
			sql.append(" SELECT count(1) FROM HAE_ALLOC_TARGET_ACCOUNT where target_id="+requestBean.getTargetId());
			 int result= ((Integer) this.namedjdbcTemplate.getJdbcOperations().queryForObject(sql.toString(), Integer.TYPE))
					.intValue();
			 return result;
		} catch (Exception e) {
			throw new SQLException(e);
		}
	}

	
	//XXX
	@Override
	public int getCountRoleUserMap(RoleUserMapRecord conditionBean) throws SQLException {
		try {
			String strCondition = BuildCondition(conditionBean);
			StringBuffer sql = new StringBuffer();
			sql.append(" select count(1) from  HRS_UMF_USER_ROLE_MAP ");
			sql.append(strCondition);
			return ((Integer) this.namedjdbcTemplate.getJdbcOperations().queryForObject(sql.toString(), Integer.TYPE))
					.intValue();
		} catch (Exception e) {
			throw new SQLException(e);
		}
	}

	@Override
	public List<Map<String, Object>> findRoleUserMap(RoleUserMapRecord conditionBean) throws SQLException {
		String strCondition = BuildCondition(conditionBean);
		StringBuffer sql = new StringBuffer();
		List<Map<String, Object>> list = null;
		try {
			sql.append("SELECT ");
			if ((conditionBean.getRowStartIndex() != 0) && (conditionBean.getRowCount() != 0)) {
				sql.append(
						  " ID,USER_ID,ROLE_ID, "
						+ " ROW_NUMBER() OVER (ORDER BY ID)  AS row_number");
			} else {
				sql.append(
						"  ID,USER_ID,ROLE_ID ");
			}
			sql.append("  FROM  HRS_UMF_USER_ROLE_MAP ");
			//if ((null != strCondition) && (strCondition.length() > 0)) {
				sql.append(strCondition);
			//}
			if ((conditionBean.getRowStartIndex() != 0) && (conditionBean.getRowCount() != 0)) {
				sql = pageSql(sql, conditionBean.getRowStartIndex(), conditionBean.getRowCount());
			}
			sql.append(" order by ID");
			list = this.namedjdbcTemplate.getJdbcOperations().queryForList(sql.toString());
		} catch (Exception e) {
			throw new SQLException(e);
		}
		return list;
	}
	//select ID,USER_ID,ROLE_ID from HRS_UMF_USER_ROLE_MAP 
	@Override
	public int saveRoleUserMap(RoleUserMapRecord createBean) throws SQLException {
		String primarykey =  String.valueOf( getAutoGeneratedPrimaryKey("HRS_UMF_USER_ROLE_MAP_S"));
		createBean.setId(primarykey);
		StringBuffer sql = new StringBuffer();
        sql.append("insert into HRS_UMF_USER_ROLE_MAP"
        		+ " (ID,USER_ID,ROLE_ID) values (:id,:userId,:roleId)");
		return this.sqlExecution(sql, createBean);
	}

	@Override
	public int updateRoleUserMap(RoleUserMapRecord reqBean) throws SQLException {
		StringBuffer sql = new StringBuffer();
		sql.append("UPDATE HRS_UMF_USER_ROLE_MAP SET ");
		sql.append(" USER_ID=NVL(:userId,USER_ID),");
		sql.append(" ROLE_ID=NVL(:roleId,ROLE_ID),");
		sql.append(" WHERE ID=:id ");
		return this.sqlExecution(sql, reqBean);
	}

	@Override
	public int deleteRoleUserMap(RoleUserMapRecord reqBean) throws SQLException {
		StringBuffer sql = new StringBuffer();
		sql.append("delete from HRS_UMF_USER_ROLE_MAP");
		sql.append(" WHERE ID=:id ");
		int a=this.sqlExecution(sql, reqBean);
		return a;
	}

	@Override
	public List<Map<String, Object>> getRoleList(RoleRecord requestbean) throws SQLException {
		List<Map<String, Object>> list = null;
		String sql="SELECT ID,TEXT,SEQ,DESCRIPT FROM HRS_UMF_USER_ROLE order by cast(id as number) ";
		list = this.namedjdbcTemplate.getJdbcOperations().queryForList(sql.toString());
		return list;
	}

	@Override
	public int getCountRoleList(RoleRecord requestbean) throws SQLException {
		try {
			StringBuffer sql = new StringBuffer();
			sql.append(" select count(1) from  HRS_UMF_USER_ROLE ");
			return ((Integer) this.namedjdbcTemplate.getJdbcOperations().queryForObject(sql.toString(), Integer.TYPE))
					.intValue();
		} catch (Exception e) {
			throw new SQLException(e);
		}
	}
	
  //XXX
	

	
}

*/